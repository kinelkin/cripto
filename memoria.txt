En esta primera práctica vamos a programar los métodos clásicos de cifrados, éstos son cifrados por sustitución (monoalfabético y polialfabético) y cifrados por transposición. Además, trataremos el criptoanálisis de los mismos.
Para ello, lo primero que hemos implementado es el algoritmo de Euclides, el cual se encarga de encontrar el máximo común divisor de dos números enteros. La función Euclidean() es la que realiza dicha tarea, apelando a la recursividad. En ella, comprobamos si a=0, en cuyo caso devolvemos b como mcd. En caso contrario, calculamos el módulo (b%a) y llamamos a la función recursivamente ahora con modulo y a (esto se realiza hasta que se cumpla la condición del if anteriormente comentada).
Además, hemos implementado la función euclideanExtended, que además de calcular el mcd de dos números enteros, calcula también los coeficientes de la identidad de Bezout, esto es x e y de la fórmula: "ax +by=gcd(a,b)". En ambas funciones, se ha empleado la librería GMP, la cual nos ha complicado ligeramente, puesto que era la primera vez que la usábamos.

Una vez hecho esto, comenzamos con el desarrollo del método afín, para el cual lo primero es comprobar que mcd de a y el módulo m es 1, puesto que en caso contrario no existiría inverso multiplicativo y no podríamos descifrar el texto. El bucle for cifra cada caracter del texto plano con la fórmula caracter_cifrado = (a*caracter_plano[i] + b) % m, los cuales son leídos/escritos en los ficheros pasados como argumento. La librería gmp complica un poco más el proceso, pero es bastante trivial. Hay que tener en cuenta que nuestro alfabeto comienza en el caracter ascii 65, de ahí la línea mpz_add_ui(total,total,65), que se asegura que los diferentes módulos resultantes comiencen a partir de tal valor (hasta un máximo de 27, que es la cantidad de caracteres en el alfabeto castellano).
Una vez cifrado nuestro texto, hacemos la acción complementaria. Leemos el fichero cifrado y lo guardamos en una cadena. Calculamos el inverso multiplicativo de a (gracias a mpz_invert contenida en la libería gmp), el cual sabemos que existe porque ya lo hemos comprobado en la función anterior. Realizamos ahora la resta del 65 y procedemos a descifrar con la fórmula caracter_descifrado = (a-1*(caracter_cifrado[i] - b) % m. Si nos da un valor inferior a 65, sumamos tantas veces el módulo como sea necesario para sobrepasar dicho valor. Una vez finalizado, obtendremos los ficheros con las salidas correspondientes y podremos leer nuestro texto descifrado.

Sabemos que la robustez del cifrado afín reside en la cantidad de claves que podemos generar, y esta viene dada por la fórmula cardinal(K) = m x funciónEuler(m). En el ejercicio a, teníamos 27x18, por tanto es bastante intuitivo pensar que si aumentamos la m, aumentaremos también su función de Euler dándonos un número más grande y por tanto más seguridad ya que poseemos más claves.
Por tanto, la decisión para este apartado b ha sido aumentar el alfabeto (de 65 a 32), para tener más posibilidad de caracteres e introducir nuevos símbolos. Así, sugerimos por pantalla al usuario que elija un modulo considerablemente elevado, para que la función de euler sea grande, obteniendo así un número elevado de claves.

Un cifrado de flujo
